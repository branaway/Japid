h1. Japid Engine Quick Manual, V0.7

h5. Bing Ran<bing_ran@hotmail.com>

h4. Document History

# 2010/2/16, first draft
# 2010/2/20, added a section for the enhanced @if@ statement 
# 2010/2/22, edited; added "open for" 




h2. Introduction

Japid is a Java-based dynamic text rendering templates system that aims to deliver the the performance.

It's a generic template engine that can be used by any Java applications to render any Java objects. It also provides adapters specifically for the Play! Framework. (The current version has some issues to be use standalone. So don't use it that way yet. To be fixed.)

The main goal of Japid is for use in large, high-traffic and highly dynamic Play! bases web applications. To reach that goal, Japid transforms templates files to clean Java source code thus the rendering can run at the raw Java speed. 

The high-performance does not come at the cost of advanced features such as page composition, tags, template inheritance, content caching, and server-side include.

This document focuses on using the Japid module for the Play! Framework. 

h2. The Design philosophy

I want:

* this template engine to have clean and practical syntax 
* the templates to be *strongly typed*: all variables rendered in a template must be clearly declared as in a Java method. Developers get all the benefits of the strong typing: compile-time error checking, performance at runtime, being debuggable, etc. 
* to use Java as the flow control and expression language. Any java classes and features can be very easily used in the templates. 
* the best possible performance out of Java. 
* it to be versatile to generate any text output and particular not limited to xml/xhtml content.
* to use right amount of convention over configuration.

I don't want:

* it to be XHTML well-formatted, since the tool is used to generate potentially any text.
* it to dependent on any other languages such as Groovy.

h2. Mechanism

* Japid engine is wrapped as a Play! module which must be configured in the *application.conf* file. 
* Japid Templates are transformed to Java source files, automatically in a running Play! instance in *DEV (development)* mode, which then are picked up by the Play! runtime in the code change detection process. 
* The Java classes that encapsulate all the layout logic can be invoked as plain java classes to generate text output, or they can be used reflectively with conventions in naming and location.  
* A few command-line tools are also provided to generate Java source files from the templates. 
* Master layouts are translated to abstract super classes, which is to be inherited by views. 

h2. Japid Module

First you need to get yourself familiar with the "Play! module concept":http://www.playframework.org/documentation/1.1.1/modules. 

To show all the version of Japid module, from the command-line:

<pre>
$ play list-modules
</pre>

And the section for Japid is like:

<pre>
~ [japid]
~   Japid template engine
~   http://www.playframework.org/modules/japid
~   Versions: 0.2, 0.3.1, 0.5.1, 0.6.0, head
</pre>

Then you can pick the version to install, usually the head version, which is also the default version. 

To install the Japid module:

<pre>
$ play install japid-0.6.0
</pre>
  
or, 

<pre>
$ play install japid-head
</pre>

or simply:

<pre>
$ play install japid
</pre>

to get the default version. 

The module goes to the @modules@ directory of the Play!'s installation root. The module contains 

# the module jars in the @lib@ directory
# the Eclipse plugin in @the eclipse-plugin@
# a sample Japid application in the @JapidSample@ 
# the source code in the @src...@ directories

Now add a reference to Japid module in the @application.conf@ file in your application:

<pre>
module.japid=${play.path}/modules/japid-head
</pre>

The next thing to do is to create the default directory structure required by Japid. From the app root:

<pre>
$ play japid:gen
</pre>

The @japidviews@ tree is now created in the @app@ directory

Now you're ready to code your models, controllers and Japid views! Every time you add a new controller you can @play japid:gen@ to create a new sub-directory to match the controller or you can create the directory manually if you're confident of your typing. 

h2. Runtime Directory Structure of Japid in Play! applications

All template files are located in @app/japidviews@ directory tree, as illustrated here:

<pre>

/app/controllers/ControllerA.java
                /more/ControllerB.java
    /japidviews/_javatags/JapidWebUtil.java
               /_layouts/
               /_notifiers/
               /_tags/
               /ControllerA/action1.html
                           /action1.java
               /more/ControllerB/action1.html
                                /action1.java
                           
</pre>

Notes:

# the @_javatags@ sub-directory contains a utility class named @JapidWebUtil.java@ that is statically imported to all generated java class definitions. One can add more static methods in the this class for use in the templates. 
# the @_layouts@ sub-directory contains global layouts that are accessible to all view templates. However as explained below, Japid layouts can be placed anywhere in the tree and can be referenced using the fully qualified name in the templates, just like the way a Java class class is referenced. 
# the @_tags@ sub-directory contains global tags that are accessible to all view templates. However as explained below, Japid tags can be place anywhere in the tree and can be referenced using the fully qualified name in the templates, just like the way a Java class class is referenced.
# the @_notifiers@ sub-directory contains email templates coded in Japid. There is a section for this later in this document. 
# The other nodes of the tree are created to match the structure of the controller and actions therein. For each controller there is a directory created which contains a bunch of template files named after the action method in the controller. The Japid converter translates the html template files to java files in the same directory. Please note though, the layouts of the template files are required only if we are going to use *implicit template binding*. A template can be placed anywhere in the case of *explicit template invocation*. There is a section of document for this later. 

h2. Japid Syntax by Examples 

The original version of Japid (around version 0.3) copied a lot of the "syntax from the Play! framework":http://www.playframework.org/documentation/1.1.1/templates. The idea was to help the Play! users to pick up the engine quickly. New and simpler syntax has been introduced over the course of one year use in real-world projects. This documents tries to compare the syntax of different flavors. 

For your information, the "Microsoft Razor Template Engine":http://weblogs.asp.net/scottgu/archive/2010/07/02/introducing-razor.aspx is a source of inspiration for some recent syntax improvement, particularly the consolidation of the usage of "`".



h3. The delimiter: @`@

Before going into the details of Japid syntax, I'll explain the special character "`", the back quote, that appears a lot in Japid templates. 

The back quote "`" plays a very important role in mixing code in templates: the delimiter;

# start a @directive@ or @command@, which is instruction to the code generator to create special Java source code.  
# start a line of pure Java code to be placed in the generated code. 
# end a script line if the line is already started by another `. 

A script line ends with it encounter a @new line, i.e., '\n'@ or another `. 

The Japid parser will first determine if the word following the ` is a command name and treat the rest of the line as Java code if it is not. 

The back quote has been selected as the special character, because:

# The back quote is the most left upper key on most keyboard ( except the escape key ) so it's easy to remember.
# It's not a key combination like the #$%, which requires pressing two keys: the Shift and 3, 4 or 5, and with both hands. I think it's easy for even the most untrained fingers. Comparing  `get title` with #{get "title"/}, the Japid syntax requires 10 key pressings and the latter requires ~20 key pressings, including all the shift keys.
# The back quote is rare enough in normal text content so it saves all the escapes.
# In most Linux shell, the ` is a very important key that indicates "command substitution": the part inside the quotes will be executed and the result be substituted in the place. I think Japid uses the symbol in exactly the same spirit.

A little annoying problem with ` is it appears less visible in some fonts, although not an issue for the fixed-width fonts that source code usually is displayed with.

Note: to escape the ` sign, please use two back quote:

@``this is normal text@




h3. Views, Tags and Layout

There are three types of templates in the Japid system:

# Views: the templates that play the central role in rendering data. Most of the rendering logic is being carried out here. 
# Tags: the templates that encapsulate some logic of data rendering and can be invoked from any other templates. They're equivalent to functions. 
# Layouts: the templates that handle the out most level of "layout" of web pages, such as the arrangement of the headers, footers, side bars, columns etc.

Views usually *extend* layouts and pass text snippet or variables to the layout to be displayed in designated location in the layout. 

Here is a simple layout template (I have left out irrelevant markups (such as HTML tags) as much as possible make the syntax structure cleaner.):

*master.html*
<pre>
This is the header. 

The title of this article is "`get title`"

`doLayout

This is the footer.
</pre>

A layout can placed anywhere but usually is in the @app/japidviews/_layouts@ directory, which is visible to any views in the project.



h3. Display a named text value: @`get <text block name>@

@`get title`@ is to retrieve a text block named "title", to be passed from any child views that inherited from this layout. The second ` can be left out if there is no more meaningful letters in the rest of the line. 

A @`get xxx@ command is usually matched by a @`set xxx@ command in the views that inherit from this layout. The @set@ command assigns a string to the variable @xxx@. If the variable is not set by the child view, an empty string is returned. Note: older version of Japid requires each variable referenced by @get@ must be @set@ in the child. Japid 0.6.2 and up makes it optional.


table{border:1px solid black; cellpadding: 1px}.
|_. Japid syntax|_. Play! syntax|
|@`get <text block name>`@|@#{get "title"/}@|


h3. Invoke the Child Layout: @`doLayout@

This command is to let the child template to render itself and substitute the command with the result. This command is pretty much the marker of templates of @layout@ type.

table{border: 1px dashed gray; cellpadding: 1px}.
|_. Japid syntax|_. Play! syntax|
|@`doLayout`@|@#{doLayout/}@|


Once we have the layout we are ready to code the main view template. 

*user.html*
<pre>
`import models.mymodels.User
`extends master
`args User user, int count

`set title:"The User Detail"
`if count
    `for (int i > 0; i < count; i++) {
        hello $user.name, and you are `tag showAge user.age`.
    `}
`
</pre>

There are a few new syntax here:


h3. Import Java Classes to Templates: @`import@ 

Purpose: same as in java.  

table{border: 1px dashed gray; cellpadding: 1px}.
|_. Japid syntax|_. Play! syntax|
|@import x.y.z@, @import static x.y.Z.*@ |@`import@|none|

Note: 

# there is no ending `.
# the ending ; is optional
# one line per import

h3. Specify the Layout for a Template: @`extends@ 

Purpose: same as in java. The super class is usually a layout template. The template name can be:

# the short file name: @master.html@, or preferrably without the extension: @master@. The file must be either in the same directory or in the @app/japidviews/_layouts@ directory.   
# the file in full path: @japidviews.mypackage.master@  
# a file in a sub directory, using a leading ".": @.sub.master@  


Note: 

# there is no ending `.
# starting from version 0.7, the layout can take parameters right from the @extends@ directive, as in
<pre>
`args String a, int b
`extends aLayout(a, b +1)
</pre>

Of course the layout must declare to accept the arguments with the @`args@ directive.

The classic syntax style is still supported:

@#{extends "mater.html"/}@

Please note: you should use double quotes to enclose the layout name in the "classic" Japid style. The profuse use of single quote in Play!'s templates are mostly replaced with double quotes in Japid's classic style to better match Java syntax. Some Japid's recent syntax goes even further to remove those quotes.  

h3. Specify the Data Objects to Render: @`args@ 

Purpose: the parameters to be passed to this template to render. The format is the same as in Java method declaration.

Note: 

# Data to be rendered must (almost) be declared passed to the templates via the @`args@ directive. However There are a few Play! specific data that are implicitly avaiable, as explained later in this document.
# The data type must be visible, meaning it must be imported. However there are several classes and packaged that are imported to any templates by default:
# Is @params@ a better name?

<pre>
import java.util.*;
import java.io.*;
import cn.bran.japid.tags.Each;
import static play.templates.JavaExtensions.*;
import static cn.bran.play.JapidPlayAdapter.*;
import static play.data.validation.Validation.*;
import static cn.bran.play.WebUtils.*;

import japidviews._layouts.*;
import japidviews._tags.*;
import japidviews._javatags.*;
import models.*;
import controllers.*;
import static  japidviews._javatags.JapidWebUtil.*;

import play.data.validation.Validation;
import play.mvc.Scope.*;
import play.data.validation.Error;
import play.mvc.Http.*;
</pre>


table{border: 1px dashed gray; cellspacing: 2px}.
|_. Japid|_. Play!|
|{border:1px grey solid}. @`args Type1 a1, Type2 a2@|none|



h3. Create a named text block: @`set@

*Purpose*: to assign a text block to a name, which can be retrieved in the layout of the current view. 

There are two forms of @set@:

# one-liner: @`set title:"some value"@. The double quotes are required. 
# block form: 
<pre>
`set title
  a very long and funny title, a very long and funny title
  a very long and funny title
`
</pre>

Notes:

# The @set@ command is location-insensitive, meaning they can be placed anywhere in a template and won't interfere with the main text flow.
# There can be multiple @set@ commands in a template, each of which should define a different text block.
# Limitations:
## If there is any reference to variables in the text block, those variables must be 1) listed in the @`args@ directive; or 2) defined within the @set@ block.
## Tags cannot be referenced in a @set@ command. This limitation will be lifted in the future. 



h3. Condition Statement @`if@ 

First of all you can use the plain Java if-else-statement :

<pre>
`if (cond) {
    xxx
`} else if (cond2){
    yyy
`} else {
    zzz
`}
</pre>

The @cond@ and @conds@ must be boolean values. This sometimes forces people to write tedious code like this:

<pre>
`if (aString != null && aString.length() > 0) {
    xxx
`}
</pre>

The Japid compiler has imported a method @cn.bran.play.WebUtils.asBoolean(Object)@ that takes any object and infers a boolean value from it to any templates it generates. So you can improve the above a little bit:

<pre>
`if (asBoolean(any_java_expression)) {
    xxx
`}
</pre>

The @asBoolean@ returns @true@ if the argument is
# none-empty string.
# a collection that has at least one element.
# an integer or long value that is not zero.
# an array that has at least one element. 
# an object that is not null.

But some people really like the @if@ to be smarter. So I have decided to enhance the @if@ statement syntax to add some smartness to it, like in Groovy:

<pre>
`if expr1 {
    xxx
`} else if expr2 {
    yyy
`} else {
    zzz
`}
</pre>
 
Basically the new syntax opens up the parenthesis to take any Java expressions and plays clever with it. The compiler translates the above code to:

<pre>
`if (asBoolean(cond)) {
    xxx
`} else if (asBoolean(cond2)) {
    yyy
`} else {
    zzz
`}
</pre>


But wait, you can go one more step further and get rid of the curly braces. Yes you can:

<pre>
`if expr1
    xxx
`else if expr2
    yyy
`else
    zzz
`
</pre>

In summary,  

# if you wrap the expression in "()", you must use the full Java syntax. The expression must be of a boolean type, otherwise it can be any data type. But check the conversion rule listed above and see if the outcome is what you're looking for.
# If you use "{}", you must them all the way through. You cannot mix them up. 

You get the idea. 


h3. Iterate over collections, arrays: @`for@ 

Actually this is the plain Java way of iterating through Java collections and arrays. The word "for" is not a special word in the Japid templates. It's pure Java code started by a back quote. Looping in Japid is Java as usual, including the closing brace.

<pre>
`for (int i = 0; i < count; i++) {
    whatever you put here. ${i}
`}
</pre>

or, 

<pre>
`String[] names = ...;

`for (String name: names ) {
    whatever you put here. ${name}
`}
</pre>

Starting from version 0.7.1, the @for@ has an "open" form that gives template authors access to a few implicit variables related to the loop. The variables are explained in the following section, but here is the syntax, basically you leave out the "()" and the "{}"

<pre>
`String[] names = ...;

`for String name: names 

    Your name is: $name,
    the total size: $_size,
    the current item index: $_index,
    is odd line? $_isOdd
    is first? $_isFirst
    is last? $_isLast

`
</pre>
 
Notes:


# Since this form involves multiple method dispatching, it's slower than the raw for loop. But the difference is in micro-second scale and probably does not matter. 
# you cannot use "{}" with the open for loop. This is @invalid@:
# there is @_isOdd@ but there is no @_isEven@

<pre>
`for String name: names { 
    xxx
`}
</pre>



h3. Enhanced looping: @`each@

Note: it's been deprecated in favor of the the "open while" format. 

The @each@ command creates a loop construct that makes available additional looping attributes for the template authors to fine-tune the data rendering. For an example:

<pre>
`each names | String name
    $name, $_size, $_index, $_parity $_isOdd $_isFirst $_isLast 
`
</pre>

Note:

# The @each @block ends with a single ` sign on a whole new line.
# In fact the above syntax is a standard way to invoke a @tag@ with a @callback body@. See later in @tag@ invocation. 
# The variable @names@ is the collection to iterate on. It can be of any of the following Java type:
## Collection
## Iterator, in which case the _size property cannot be determined before hand and is given a value of -1.
## Iterable, in which case the _size property cannot be determined before hand and is given a value of -1.
## array of anything
# The construct after the vertical line is the declaration of the instance variable for each round of iteration. The data type must present before the variable name. In the body of each we see a bunch of additional variables related to the current iteration:

table{border: 1px dashed gray; cellspacing: 2px}.
|_. Variable|_. Meaning|
|{border:1px grey solid}. int _size| the size of the collection or array, -1 if not determined in the case of iterable as the collection|
|{border:1px grey solid}. int _index| the index of the current instance in the collection |
|{border:1px grey solid}. boolean _isOdd| true if the index is odd, false if it is even|
|{border:1px grey solid}. String _parity | "odd" for the odd lines, "even" for the even lines|
|{border:1px grey solid}. boolean _isFirst | true if the current instance is the first in the collection|
|{border:1px grey solid}. boolean _isLast| true if the current line is the last in the collection|


h3. Java Expression: @${expression}@

The string value of a @Java expression@ can be interpolated in text stream using the ${} syntax, as is used in Play!. The {} signs can be omitted if doing so won't make the expression fuse with the rest of the context thus cause confusion to the compiler (or your eyes). For examples:

<pre>

${user.name} == $user.name
${user.name.length()} == $user.name.length()

</pre>

As long as the expression is properly delimited by none identifier characters, the {} can be left out. The {} is mandatory in Play! default engine. 

Note: Japid by default does *not* escape the string value of expressions to make it html safe, like what Play! does. One can simply do:

@${escapeHtml(expr)}@

to get the effect. The @escapeHtml()@ is a static method defined in @play.templates.JavaExtensions@ class in Play!, which is automatically imported to any Japid templates. There are other useful static methods in that class that are available directly in the templates. See "JavaExtension":http://www.playframework.org/documentation/1.1/javaextensions. 



h3. Safe Property Navigation: @`supressNull on@

An expression like @$user.name.length()@ can cause potential problems if any of the nested properties is null, in which case the template will throw NPE. There is a so called @safe navigation operator@ in Groovy: @p?.p2?.p3@. Java does not have this. Instead Japid introduces a directive to suppress the NPE in property navigation.

<pre>
` suppressNull on

` String a = "a";
safe to do $a.length()

` a = null;
also safe to do a.something too: $a.length()
</pre>

The second @$a.length()@ in the above sample throws an NPE, which is caught by the template and discarded with the @`suppressNull on@ directive at the top of the script. what you end up with is an empty string "";

Note: only NPEs thrown after the directive will be suppressed. 


h3. Simple Tag Invocation: @`tag tagName arg1, arg2...`@

Back to the view template:

*user.html*
<pre>
`import models.mymodels.User
`extends master
`args User user, int count

    `for (int i > 0; i < count; i++) {
        hello $user.name, and you are `tag showAge user.age`.
    `}
</pre>

In the body of the for loop we are invoking a @tag@ called @showAge@. Think of a tag as a function defined in a separate file. Here is the tag file:

*showAge.html*
<pre>
`args int age

you are $age years old
</pre>

The above tag simply take an @int@ as the age and append "years old" to it. 

The tag invocation has an alternative: 

@`tag tagName(arg1, arg2...)`@

which looks more like function calls.

And the @`tag@ command can be further cut short as @`t@ as in:

@`t tagName(arg1, arg2...)`@

Note: the closing @`@ can be omitted if there is no other letters in the rest of the current line, for a new-line character is a valid tag closing symbol.



h4. locating a tag file

Similar to locating a layout file, the tag name can take a few forms:

# a simple name: @tagName@, which can be either in the same directory as the current template file, or in the @japidviews._tags@ directory.
# a full package form: @japidviews.my.pack.tagName@, or
# a relative form: @.sub.tagName@, which is located in a sub directory of the current directory. 

Also please note that one can use "/" in lieu of "." but I prefer the dot syntax. 



h3. Advanced Tag Invocation: @`tag tagName arg1, arg2... | type1 arg1, type2 arg2`@

A tag can take a block of template text as the last argument. For an example:

<pre>
`tag fancyTag "hello" | String name
    what a fancy name: ${name}!
`
</pre>

There are two arguments to the tag invocation:
# @"hello"@, a String, and
# @String name \n what a fancy name: $name@, a template. 

The vertical line "|" separates the regular arguments and the template block. Note: the Japid parser requires the presence of this separator even if the template does not have any parameters. 

This is valid:

<pre>
`tag fancyTag "hello" | 
    what a fancy name!
`
</pre>

And this is not:

<pre>
`tag fancyTag "hello"
    what a fancy name!
`
</pre>

The reason is that a new-line character '\n' is a tag terminator if the parser does not detect any a "|" in the argument list. The "|" tells the parser that a template block is following the current line. 

The template parameters passed to a tag are rendered by a @`doBody arg1, arg2...@ command in the tag file, as explained in the *Tag Definition* later in this document. 



h3. Tag definitions

Any views can be used as tags. The above mentioned view file:


*user.html*
<pre>
`import models.mymodels.User
`extends master
`args User user, int count

`for (int i > 0; i < count; i++) {
    hello $user.name, and you are `tag showAge user.age`.
`}
</pre>

can be invoked from other views. e.g.,

*another view*
<pre>
` User aUser = ...;
`tag user(aUser, 10)

</pre>

In another word, regular views can be invoked either from the controller actions or from other views. 

However, the regular views cannot take a template as an argument, unless it contains a special tag: @`doBody@, as in:

*fancyTag.html*
<pre>
`args String m

<p>I got $m, and the body is:</p>
<p>
`doBody m
</p>
<p>done.</p>
</pre>

Note: the argument list of the @`doBody@ command must match that declared after the "|" symbol in the invoking templates. 

The @doBody@ command passes matching arguments to the passed-in template. This behavior is sometimes referred to as "call-back".

With some imagination, a tag can be effectively used as a layout to a view. The layout part is done in the tag and the main template section is passed in as the last argument of the tag invocation.  

Note:

# tags can invoke other tags. 
# tags usually don't inherit from layouts. 
# Tags can be placed anywhere in the @japidviews@ tree. 

h3. Verbatim text: @`verbatim@

Purpose: to display a block of text un-parsed by Japid. 

<pre>
`verbatim
    OK, anything inside this block is not parsed: `command, ${expression}, etc
`
</pre>

Note: a @verbatim@ block must be closed by a standalone back quote that occupies a whole line.



table{border: 1px dashed gray; cellspacing: 2px}.
|_. Japid|_. Play!|
|{border:1px grey solid}. @`verbatim ....  \n`@|  #{verbatim}... {/}|


h3. More about Passing Data to the Layouts

Previously I have explained how to use the @'set@ command to create a named text value and use the @`get@ in the layout to place the value in the output. 

There are two other ways to pass data from the child templates to the layouts. 

h4. Passing data in the @`extends@ Directive (new in Japid v0.7)

The @extends@ directive allows passing objects to the layout in this way:

*child template*

<pre>
`args String a
`extends myLayout(a, 123, "home")

</pre>

*The layout*

<pre>
`args String a, int b, String c

do whatever with them

</pre>

Smells Scala?

The only limitation is the args to pass must either be from the arg list of the current template or a new object created inline. You cannot declare a variable somewhere else and pass it to the super class, like in:

<pre>
` String a = "hello"
`extends myLayout(a)
</pre>

h4. Define a local method with @`def@ and invoke it with @get@ method

The @`def@ directive create a local method that return a String. The method can then be invoked in the same templates. An example:


*the child template*
<pre>
`extends defLayout

`def foo
    `String s = "hi there";
    hello $foo2(s)
`

`def foo2(String p)
    hi $p!
`

*{ the old syntax of def }*

#{def bar}
    `String s = "hi2";
    hi $s!
#{/}

#{dummyTag get("bar")/}

*{ can call it directly }*

$foo()

</pre>

The @`def foo@ block defines a method named @foo@. The method body declares a variable @s@ and then calls another local method named @foo2@ with the variable. The @foo2@ is defined to take a String argument. Both return a string which is the result of interpolating the data in the text of the bodies. The arguments received from the @`args@ statement are avialable in the method bodies.
 
The @def@ blocks can be though of tags defined inline, instead of in separate files. You will find it very useful. 


The methods defined in the templates can be invoked with reflection. Japid provides a predefined method named @get@ (not to be confused with the @`get@) that can be used to invoke the method. In the above example, @#{dummyTag get("bar")/}@ is the "old" classic Play! way of invoking a tag. The argument is actually a function call to invoke the @bar@ method defined above it (in the classic Play! style again). One limitation though, the @get@ method can only invoke method without parameters. Future Japid will probably have another @get@ that can take additional arguments. 

The @get()@ can be used in either the super class or the child class to reflect methods. The following example uses it call the @foo()@ defined in the child. 
  
*defLayout.html*
<pre>
$get("foo")
#{doLayout/}
</pre>

Effectively the data is passed from the child to the layout. 



h2. Using Implicit Data Objects in Templates 

Although it has been said that all data passed to the templates must be declared, there are a few Play! specific objects, implicitly available in Japid templates. If you open any Java source code derived from the templates (including the views, layouts and tags), you'll see in the main body that there are a few objects declared:

<pre>
    final Request request = Request.current();
    final Response response = Response.current();
    final Flash flash = Flash.current();
    final Session session = Session.current();
    final RenderArgs renderArgs = RenderArgs.current();
    final Params params = Params.current();
    final Validation validation = Validation.current();
    final cn.bran.play.FieldErrors errors = new cn.bran.play.FieldErrors(validation);
    final play.Play _play = new play.Play();
</pre>

TODO: XXX

h2. Invoking templates in Controllers 

Japid templates are compiled java classes which can be invoked statically or reflectively. 

Note: to use Japid in a controller, one must let the controller to @extends@ a special Japid controller super class named @cn.bran.play.JapidController@, instead of the Play!'s default @Controller@ class.

h3. Explicit Template Binding

Since all Japid templates are compiled to Java classes, one can use them directly anywhere, of course including in the controller actions. Given a template @japidviews/MyController/foo.html@, Japid will generate a Java class named @japidviews.MyController.foo@. The entry point of using this class is:

<pre>
    public cn.bran.japid.template.RenderResult render(Bar bar)
</pre>

The @RenderResult@ object contains the text which is the result of the template rendering, and the additional HTTP headers. As you may have known, The Play! way to return a result from a controller method is to throw an object of @Result@ type. To use the result from the template class, one needs to wrap it in a @cn.bran.play.JapidResult@ object and throw it out, like this in a controller action:

<pre>
    throw new JapidResult(new foo().render(args...));
</pre>

Of course all the classes must have been properly imported before use or one must use the fully qualified names. 

The @JapidContrller@ super class offers a static method @render(RenderResult rr)@ to hide the JapidResult, so one can write:

<pre>
    render(new foo().render(myBar));
</pre>

Slightly cleaner.

As you may guess, invoking a template class directly does not require the class to be in a specific package. There is no need to match the name or the package of the template with the name of the action, the class or the package. The minimum requirement is the templates are in the @japidviews@ tree, since the template converter will only scan this tree for Japid templates. 


h4. How and when are the template files translated to Java source code?

Three ways and timing.

h5. Conversion method 1: command-line tools

There are four Japid command-line commands that one can use in the application root:

# @play japid:mkdir@: check the proper @japidviews@ directory tree and create missing elements if necessary. 
# @play japid:gen@: do @mkir@ first then translate all templates in html, xml, json to Java sourse code. Most of the time this command supersedes the @japid:mkdir@.
# @play japid:clean@: remove all generated Java source files derived from the templates. 
# @play japid:regen@: do @clean@ and @gen@

These commands are useful in what I call the "cold development" mode - in compile-time and you use the *static linking* (a.k.a. *explicit template binding* ) of the templates, i.e., you instantiate the java class derived from the view template in the controller actions and invoke the render() method directly. 

The workflow in this mode is:

# create the model classes if they're to be rendered in the views.
# create the Japid views in html. 
# run the @play japid:gen@ to get the Java files derived from these templates. 
# statically link the renderer in the actions.  

However as explained before, *implicit template binding* is a lot more flexible and does not require the use of the code generation tools. See the next section of this document.

*Tip!* Let me show you how you can configure these commands in Eclipse to make using these commands less troublesome if you are using Eclipse as the main IDE to develop applications. 

The most used command is probably @play japid:gen@. 

Here are the steps to create a quick link to the command in Eclipse:

# Open menu: Run -> External Tools -> External Tools Configuration
# Create a new entry with the following attributes:

*Name*: japid-gen

Under the *Main* tab:

# *location*: D:\home\bran\projects\play\play.bat (change this to your start script of your Play! installation).
# *Working Directory*: ${project_loc}
# *Arguments*: japid:gen

Under the *Refresh* tab:

# Check the "Refresh resources upon completion"
# Select the "The project containing the selected resource"
# Check the "Recursively include sub-folders"

Now I can translate the latest templates to Java code right from the IDE with just two clicks. 

Two other most useful commands are @play japid:regen@ and @play eclipsify@ (if you're an Eclipse user). The latter is not directly related to Japid, but it's convenient when you upgrade either the Play! installation or the Japid module.

h5. Conversion method 2: care-free conversion in DEV mode.

The Play! runtime in DEV mode detects file changes automatically before processing any new HTTP requests or *job* activation, and Japid module will step in to translate the newly added/changed template files automatically. Java files derived from removed templates will get removed automatically too. 

h5. Conversion method 3: using the Japid plugin for Eclipse

There is a plugin for Eclipse that takes care of templates/Java synchronization at compile time. One don't need to run the app in DEV mode to get the templates automatically translated. The detail is explained in a later section of this document.  

In conclusoin, there are good and bad sides of using a template explicitly as a Java class:

* Pros:
*# fast, since this is a regular Java class instantiation and method invocation.
*# statically linked and thus there is compile-time check of argument binding. 
* Cons:
*# verbose: the classes need to be imported; the results need to be thrown out.
*# strict in workflow: one must write the templates first and convert them to Java classes (manually or automatically, depending on the development environment) before they can be used in controller actions. 

h3. Implicit Template Binding

To decouple an action and the template it defaults to render, the @JapidController@ provides a method @renderJapid(...)@ to hide the process of invoking the renderer. The method depends on the parallel package structure of the @controllers@ tree and the @japidviews@ tree to locate the right template to render with. 

For an example, given the action method @controllers.p1.MyController.foo(...)@, the default template name is @japidviews/p1/MyController/foo.html@.

The @renderJapid@ makes binding to the default template a lot easier as shown below:

<pre>
    public static void foo(...) {
        Bar bar = ...;
        renderJapid(bar);
    }
</pre>

Note: the Play!'s default rendering engine binds the arguments *by name*. This means one must give any objects to be passed to the template a name or the template engine won't find them. In contrast Japid conveniently binds arguments by position, just like in any java method invocations. One does't need to match the names of the variables in the action with those in the templates. 

* Pros:
*# a lot shorter.
*# the templates do not need to exist and compiled to Java classes before template authors writing the action code. 
* Cons:
*# slightly slower, usually less than 1 _Î¼s_, since it uses reflection to invoke the rendering code.
*# no compile-time check on the parameters. 
*# need to match the directory structure of the japid templates to the controllers'. The @play japid:gen@ or the Eclipse plugin would help to make it less a problem. 

I personally find using the implicit template binding a lot easier on me, since I can work in the order of a request processing flow very naturally in this mode: the models, the controllers and then the views. I don't need to manually convert the templates files at all. I need to however make sure the @japidviews@ directory tree is synchronized with the @controllers@ tree in terms of the package names and the files names. With the *Japid Plugin for Eclipse*, which is the IDE of my choice, I don't even need to worry about the package structure and I can focus on the real coding logic. The Eclipse plugin will guide me to create the views in the proper locations, as described later in this document.

Now, what if there are multiple possible Japid templates to render with in an action?

Three ways:

# statically link the template class as explained in the previous section.
# use the @JapidController.renderJapidWith() method@: for an example: @renderJapidWith("more/MyController/anotherTemplate.html", bar)@ will render the @bar@ object with the @japidviews/more/MyController/anotherTemplate.html@ template. The template name is a relative name to the @japidviews@ directory. It can also be in the form of a Java class name: @more.MyController.anotherTemplate@.
# call other methods and render implicitly, i.e., *action chaining*. 

The below example demonstrates all ways of template bindings:

<pre>
    public static void foo() {
        Bar b = ...;
        if (cond1) {
            // implicit binding
            renderJapid(b);
        }
        else if (cond2) {
            // action chaining
            dontRedirect();
            bar(b);
        }
        else if (cond3) {
            // static linking
            render(new foo().render(b));
        }
        else {
            // explicit dynamic binding
            renderJapidWith("more.MyController.foo", b);
        }
    }

    public static void bar(Bar b) {
        // implicit binding
        renderJapid(b);
    }     
</pre>

In the above example, when @cond1 == true@, the template to render with is @foo.html@; when @cond2 == true@, @bar.html@ will be used to render the data, etc. Note, @JapidController.dontRedirect()@ must be called to avoid an HTTP *redirect*, since calling another action in Play! runtime will trigger an HTTP redirect. Please note, Play!'s original author does not like action chaining for some reason. In fact there is no way to do action chaining without creating an HTTP redirect with the classic Play! controllers. The @dontRedirect()@ opens up the possibility.


h2. Invoking Actions in Templates

Sometimes I call this feature "dynamic server-side include". 

Let's consider a porlet-like web page. It's composed of multiple panels each of which displays totally different content. Let's say we have already created controller actions and corresponding views to display each of the content panels. How can we reuse all the controllers and views as sort of "components" in the portlet page?

This is a page composition that is not supported by the default Play! rendering pipeline. 

Japid provides a special command named @`invoke@ or @`a@ for action to help users to invoke a controller action right from a view template. 

In a controller:

<pre>
package controllers.more;
import cn.bran.play.JapidController;

public class Portlets extends JapidController {
    public static void index() {
        renderJapid("a", "b");
    }

    public static void panel1(String a) {
        renderJapid(a);
    }


    public static void panel2(String b) {
        renderJapid(b);
    }
}
</pre>

Highlight anywhere in the index() method and @ctrl-alt-v@ and say "yes" to the question and you are in the index.html. Change it to something like this:

<pre>
`args String a, String b

`invoke controllers.more.Portlets.panel1(a)

`a controllers.more.Portlets.panel2(b)
</pre> 

The @invoke@, or the short form @`a@, basically invokes the action method in the controller with the argument and incorporate whatever content the action generate right on the spot. Each of the controller action and view pairs becomes a reusable unit of component. This is a lot more powerful than other mechanisms such as @tags@ since you have the full Java in your hand. 

I feel this is very intuitive for many developers to compose complex pages, although the original Play! developers do not seem to like this idea. 

h3. Advanced Caching with Invoke

The @`invoke@ command can take one optional argument: a timeout value to cache the result from the action invocation. 

Let's change the above template a little bit:

<pre>
    `args String a, String b
    
    `invoke controllers.more.Portlets.panel1(a)

    `a controllers.more.Portlets.panel2(b), "10s"
</pre>

I have attached a timeout specification to the second action invocation. The timeout value is a string such as "1s", "2mn" ("mn" for minute), "3h" and "4d" ("29d" maximum), to specify how long to cache the result content from the action.  

There is another way to specify if the result should be cached and for how long: using the Play! @CacheFor@ annotation on the action, like this:

<pre>
package controllers.more;
import play.cache.CacheFor;
import cn.bran.play.JapidController;

public class Portlets extends JapidController {

    @CacheFor("10s")
    public static void panel2(String b) {
        renderJapid(b);
    }
}
</pre>

Note: The timeout spec in the @`invoke@ command overrides any @CacheFor@ annotation. 

Now on to the "advance" part, *nested caching*. 

What if the first level cached content is from a template that contains another cached @`invoke@? Will the outer cache "annihilate" the inner cache? The answer is "no".

This is what will happen: the inner cache will _penetrate_ the outer cache and operate by its own timeout pace. Consider a scenario where a complex home page (in our example the index.html) is cached for 20 seconds, but the headline news section (the panel2.html in our example) on the page will need to be updated very 10 seconds (or refresh every time a new request comes in). 

An Example: 

*The controller:*

<pre>
package controllers.more;
import java.util.Date;

import play.cache.CacheFor;
import cn.bran.play.JapidController;

public class Portlets extends JapidController {
    @CacheFor("20s")
    public static void index() {
        renderJapid("a", "b");
    }


    public static void panel1(String a) {
        System.out.println("panel1 called");
        renderJapid(a);
    }


    public static void panel2(String b) {
        System.out.println("panel2 called");
        renderJapid(b);
    }


    @CacheFor("5s")
    public static void panel3(String whatever) {
        System.out.println("panel3 called");
        renderText("<div>" + new Date() + "</div>");
    }
}

</pre>

The view:

<pre>
    `args String a, String b
    
The outer most content is cached for 20 seconds, using the CacheFor annotation. ${new Date()}

this part is never cached.
        `invoke controllers.more.Portlets.panel1(a)

this part is cached for 10 seconds. Note the timeout spec with invoke overrides CacheFor annotation.
        `a controllers.more.Portlets.panel2(b), "10s"

this part is cached for 4 seconds, specified with CacheFor annotation in the controller.
        `a controllers.more.Portlets.panel3(a + b)
</pre>

With this composition pattern, the whole page will be cached for 20 seconds, and the @panel2@ will be cached for 10 seconds, the @panel3@ is cached for 4 seconds since the action is annotated with a @CacheFor("4s")@. The panel1 part will not be cached at all since there is no cache control at all. 

</pre>

If you have sharp eyes, you may notice that the content in a cached block is usually updated one second before the specified timeout value. Japid builds a mechanism to *pre-expire* an entry 1 second in advance. The first client to get the *pre-expire* is responsible for updating the cache while other requests coming during the one second window will still get the cached entry until the entry is *fully expired*. This mechanism is to make sure the cache will be updated by only one thread thus perform seamlessly in a highly concurrent environment.  



h2. Use Japid to Render Email Content.

Japid has a replacement for Play!'s email rendering engine. The mechanism is very similar to the "Play!'s email rendering flow":http://www.playframework.org/documentation/1.1.1/emails, but takes full advantage of Japid templates. 

This is how:
1. Create a @mail controller@ (a.k.a. @mailer@) in @app/notifiers@ or any sub-directory of it. A @mailer@ is conceptually equivalent to an action controllers except it must extend @cn.bran.play.JapidMailer@. Here is a sample mailer:

<pre>
public class CouponJapidMailer extends JapidMailer {
    public static void sendEditorEmail(String title, String content) {
        setSubject(title);
        addRecipient("bing_ran@hotmail.com");
        setFrom("memberships <memberships@maimaijia.cn>");
        // add an attachment
        EmailAttachment attachment = new EmailAttachment();
        attachment.setDescription("A pdf document");
        attachment.setPath(Play.getFile("rules.pdf").getPath());
        addAttachment(attachment);
        send(content);
    }
}
</pre>

* The @send@ method is the counterpart  of @renderJapid(...)@ in regular controller. It searches for the @japidviews/_notifiers@ directory for the matching template. e.g.:

Given a mailer action @sendNote()@ in:

<pre>
app/notifiers/MyNoti.java
</pre>

The @send()@ action's default template is:

<pre>
app/japidviews/_notifiers/MyNoti/sendNote.html
</pre>

If the mailer is 

<pre>
app/notifiers/org/MyNoti.java
</pre>

then the default template is:

<pre>
app/japidviews/_notifiers/org/MyNoti/sendNote.html
</pre>

2. Create the email content renderer as you would do for any regular Japid view templates. You can use the full capacity of Japid of course, including layouts, tags, etc.

3. Invoking a mailer in your controller actions as you would invoke a static method. e.g.:

<pre>
    // in a regular controller
    public static void feedback(String title, String content) {
        // ...
        CouponJapidMailer.sendEditorEmail(title, content);
    }
</pre>

Note:

# The email sending process takes place in the current thread therefore it is a synchronous process. This has impact on the scalability of sending large amount of emails simultaneously. This is an area for future improvement.
# The mailer can be invoked in Play! jobs in the same way.
 



h2. Using the Japid Eclipse Plugin

First of all, the plugin is based on the PlayClipse project for Play! In fact the new plugin still keeps the name and tries to keep itself compatible with the default rendering engine. 

h3. Source code
 
- https://github.com/branaway/playclipse, branched from https://github.com/erwan/playclipse

h3. Features:

# It provides a few "wizards" to help create Japid Play! classes/files.
# It integrates the Japid template transforming process to the incremental and full project building processes of Eclipse, thus eliminates any manual process in applying Japid templates.
# The plugin as of now offers the same level of features that are in the original plugin for the  groovy-based templates to the Japid template engine.
# It enables some menu items and short-cuts to navigate between actions and Japid views, japid html templates and the derived Java source code. 
# It provides an enhanced Play HTML editor that recognizes some Japid syntax, notably the back single quotation mark syntax - the flagship Japid syntax.  
# It enables Ctrl-click navigation in html views to actions, layout templates and tags. 
# It has also fixed a few bugs coming with the original plugin and enhanced the pop-up menu in the views and editors.

h3. Installation:

The plugin is in the @eclipse-plugin@ directory of the Japid module. 

# Put the jar file in the @dropins@ directory of the Eclipse installation and start/restart the IDE. 
# You'll be able to see a new menu named "JapidPlay" in the main menu bar. A new entry of the same name is also added to the context menu in the Java package navigation view, Java editor. A new html editor called HTML(Play) is also registered as an editor for html files. You'll need to use this editor to edit HTML templates to gain the syntax highlighting, artifact navigation etc. 

If you don't see the JapidPlay menu in the IDE workbench window menu bar, please try starting the IDE with a command line option : 

<pre>
$ ./eclipse -clean 
</pre>
 
The plugin has been tested with Eclipse Helios (3.6).

Got troubles?

# If you have used the classic PlayClipse plugin, please remove it from the @dropins@ directory of your Eclipse installation and use the @-clean@ command line option to start the IDE.  
# Another trick is to remove the plugin jar before starting Eclipse. Once you're in, shut it down. Put the jar in the @dropins@ and start the IDE again. 


h3. Usage

First of all, right click on your Japid/Play project and invoke menu @JapidPlay! -> "Enable Play! Nature"@ or the Japid transformation will not be integrated with the project building process, neither the popup menu will display the proper menu items.

The enablement of the Play nature does a few things:

# It adds a Japid builder in the project builders list, before the Java builder. 
# The builder creates the necessary @japidviews@ tree if it's not there. This is the equivalent to the @play japid:mkdir@ command. 
# The builder also adds two files in the @japidviews@ tree: @SampleLayout.html@ in the @_layouts@ and @SampleTag.html@ in the @_tags@ directory. These two files are not required by Japid _per se_. They are simply examples. Please leave them there since (actually the plugin will create them if you delete them.) any example views created by the Japid plugin reference them and there will be compile-time errors without them. I figure this is good for Japid beginners, but it may change in the future.
# The builder does a fresh template translation and convert html templates to java source code, which is automatically picked up by the Java builder.

Now click on the @controllers@ directory or sub-directory to select it and invoke "New Controller" command from the main "JapidPlay" menu or the context menu (by right-clicking on the package node). Of course you can create the class without bothering the wizards. 

Assuming you have highlighted the @controllers.more@ node, the default controller created by the plugin looks like this:

<pre>
package controllers.more;
import play.mvc.*;

import cn.bran.play.JapidController;

// make sure you have 
//      module.japid=${play.path}/modules/japid-{version}
// in your application.conf file, and "play eclipsify"
// if you notice the JapidController is not found.

public class MyController extends JapidController {

    public static void index() {
        renderJapid("Hello world!", 123);
    }

}
</pre>

As you can tell, the sample controller renders data with the default Japid template. Now let's try navigating from the action to the default view. 

Move the cursor to anywhere in the action method, which starts from the @public@ modifier and ends at the closing curly brace of the method. Now you can navigate to the view either opening the main JapidPlay menu and invoke the "Go to view" item or right-clicking to bring up the context menu and invoke @JapidPlay! -> Go to view@. Of course @Ctrl-Alt-v@ is very handy here.

Since you don't have the view ready yet, the plugin asks if you would like to create a view at the proper location. Saying "yes" and you'll get a sample view created in the right location.

<pre>
`extends SampleLayout.html
`args String s, int i 

`set title:"index"

hello ${s}, ${i}.
Here goes your Japid template content.

call a tag: 

`tag SampleTag "world" 
</pre>

It should have already been compiled to a Java file named "index.java", and the Java code should compile clean, assuming that you have enabled the "Play Nature" on the project. If you don't see the derived Java file in the same package, follow this procedure:

<pre>
    if (you have enabled the "Play nature") {
        invoke "JapidPlay! -> Disable Play! nature" on the context menu;
    }
    invoke "JapidPlay! -> Enable Play! nature" on the context menu;
</pre>

I have found occasionally I need to re-enable the Play! nature to get the Japid auto-compilation going. This is an issue to be explored. 

The Japid plugin automatically synchronizes the html templates to the derived Java files if the project is set to build automatically: 

# when you add a new template, a new Java file is derived from it and is placed in the same package. You can immediately spot any errors in the generated Java code and change your template to fix it. Here you get the full benefit of static typing.
# when you update a template, the derived Java file is also updated. Again, you get the error checking. 
# when you delete or rename a template, the derived Java file is also removed or renamed accordingly. 
# when you invoke the @Project -> clean@ menu command, all the derived Java files are removed. If the "Build automatically" option is on, all the templates are translated to Java files immediately, effectively equivalent to the @play japid:regen@ command. 

The template editor also does some basic error checking and rudimentary code completion, but it is far from being a sophisticated full-featured template editor. It does not

# edit html tags.
# do serious code completion.
# parse in the Java expressions.

But I have found it offers great assistance in navigating the code, which makes the users a lot more productive.

h3. Navigating in the views

The plugin offers an HTML editor that is Japid-aware. 

If you have already used another HTML editor in your Eclipse IDE, usually your html files are associated with them and are opened in one of them. You'll need to use the HTML editor from the plugin to take advantage of some of the nice features. 

In the @Package Explorer@, right-click on the template file and @Open with -> HTML(Play!)@. 

The current Play html editor is unfortunately not HTML-aware(something to improve on later), but it offers some nice Japid-aware features:

# highlighting Japid constructs: Japid expressions, scripts, commands such as @`tag@, @`extends@, etc. 
# Ctrl-clicking on the @layouts@, @tags@, @imports@ directives to navigate to the target files. 
# navigating to the controller action that uses this template as the default templates with the @Go to action@ context command, or simply @ctrl-alt-a@. I find myself using this key combination and @ctrl-alt-v@ a lot to switch between  the actions and the views.  
# navigating to controller actions in the reverse route lookup expression: @controller.action(), again, with the @Go to action@ command.
# navigating to the derived Java files, with the @Go to generated Java file@ context command.   





h2. Debugging the Templates

Since all Japid templates are transformed to Java source files, debugging the views is as easy as debugging any Java code in Play!. Nothing fancy here. 

I personally find it rare to need to debug the views, since usually it will work if the Java code compiles. That's compile-time error checking at work. You'll need to pay attention to the parameter list of the templates and make sure they match that in the actions that using *implicit template binding*.   

Lastly, there is a handy command you can use to quickly log any data in your Japid templates. The command is natually called @`log@. 

<pre>
`args String a

`log
`log "the value of a: " + a
`log 1 + 2

</pre>

The @log@ command will print the string value of whatever Java expression following it to the system console, with template name and line number information, such as 

<pre>
japidviews/templates/log.html(line 5): 
japidviews/templates/log.html(line 6): the value of a: Hello 
japidviews/templates/log.html(line 7): 3
</pre>

By the way, you can use the @log@ command without any arguments. You end up with just the template name and line number in the console, useful if you want to know where you are. 


h2. Use the Sample Application in the Module

There is a sample application distributed with the japid module in the @JapidSample@ directory. It does not serve any real world purpose other than as a demo of Japid features.  

This is how to run the sample:

# open the @application.conf@ to make sure it has a proper reference to the japid module.
# run command @play japid:regen@ to regenerate all the template Java code.
# if you would like to load it in Eclipse for example, you run @play eclipsify@ command and open it in Eclipse. 
# start the application and hit @http://localhost:9000/@, you'll get a page with many links to different actions.
# follow those links to see how each features are used in the demo code. 

h2. Using Groovy and Japid in the Same Project

xxx

  
h2. Future work

# keep improving the Eclipse plugin
# find more ways to simplify japid syntax.
# keep improving the documentation.
# assimilate some fancy features from the @Lift@ framework. Parallel action blocks comes to my mind. 
# release a package that can be used in any Java projects.

Thanks for your interests in Japid!


